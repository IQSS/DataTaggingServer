@( aValue: edu.harvard.iq.datatags.model.values.TagValue )

@import edu.harvard.iq.datatags.model.values._

@atomicValue( value:AtomicValue ) = {
  <div class="value value-simple">
      @slotTypeTitle(value.getType)
      @valueAtom(value)
  </div>
}

@todoValue( value:ToDoValue ) = {
  <div class="value value-todo">
    <span class="typeName">@value.getType.getName</span>
    <span class="valueAtom">TODO</span>
  </div>
}

@aggregateValue( value:AggregateValue ) = {
  <div class="value value-aggregate">
    <span class="typeName">@value.getType.getName</span>
    @if( value.getValues.isEmpty ) {
        <span class="valueAtom">empty</span>
    } else {
      @for(  sv <- value.getValues ){
        @valueAtom(sv)
      }
    }
  </div>
}

@compoundValue( value:CompoundValue ) = {
  <div class="value value-compound">
    <div class="typeName">@value.getType.getName</div>
      <ul>
        @for( tp <- value.getNonEmptySubSlotTypes ){
          <li>@renderValue( value.get(tp) )</li>
        }
      </ul>
  </div>
}

@anyValue( value:TagValue ) = {
 <div class="value value-compound">
    <span class="typeName">@value.getType.getName</span>
    <span class="valueAtom">@value.toString</span>
  </div>  
}

@renderValue( value:TagValue ) = {
    @value match {
        case v:AtomicValue => {@atomicValue(v)}
        case v:AggregateValue => {@aggregateValue(v)}
        case v:ToDoValue => {@todoValue(v)}
        case c:CompoundValue => {@compoundValue(c)}
    }
}

<div class="tagvalue-container">
@renderValue( aValue )
</div>
